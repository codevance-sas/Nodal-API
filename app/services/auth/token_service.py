import logging
import uuid
import hashlib
import secrets
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, Any, Tuple

from jose import JWTError, jwt
from fastapi import HTTPException, status, Depends
from sqlmodel import Session

from app.core.config import settings
from app.db.session import session
from app.crud.auth_tokens import auth_token_crud
from app.services.auth.email_service import email_service

# Configure logging
logger = logging.getLogger(__name__)

class TokenService:
    """
    Service for handling JWT token operations including creation, validation, and verification.
    This service encapsulates all token-related logic to improve separation of concerns.
    """
    
    def __init__(self):
        self.algorithm = settings.JWT_ALGORITHM
        self.access_token_expire_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
        self.refresh_token_expire_days = settings.REFRESH_TOKEN_EXPIRE_DAYS
        self.auth_token_expire_days = settings.AUTH_TOKEN_EXPIRE_DAYS
        self.jwt_secret_key = settings.JWT_SECRET_KEY
        
    async def generate_email_token(self, email: str, db: Session, is_admin_generated: bool = False) -> Tuple[bool, str]:
        """
        Generate a token and send it to the specified email.
        
        Args:
            email: The email address to send the token to
            db: Database session
            is_admin_generated: Whether the token is being generated by an admin
            
        Returns:
            Tuple of (success, message)
        """
        # Check if the email domain is allowed
        if not email_service.is_domain_allowed(email):
            return False, "Email domain not allowed"
            
        # Check if a token can be generated for this email
        if not is_admin_generated and not auth_token_crud.can_generate_token(db, email):
            return False, "A valid token already exists for this email"
            
        # Generate a secure random token
        token = secrets.token_urlsafe(32)
        
        # Hash the token for storage
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # Store the token in the database
        auth_token_crud.create_token(
            db=db,
            email=email,
            token_hash=token_hash,
            expires_in_days=self.auth_token_expire_days,
            is_admin_generated=is_admin_generated
        )
        
        # Send the token via email
        email_sent = await email_service.send_token_email(email, token)
        
        if not email_sent:
            return False, "Failed to send email"
            
        return True, "Token generated and sent successfully"
        
    def verify_email_token(self, token: str, db: Session) -> Optional[str]:
        """
        Verify an email token and return the associated email if valid.
        
        Args:
            token: The token to verify
            db: Database session
            
        Returns:
            The email associated with the token if valid, None otherwise
        """
        # Hash the token for lookup
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # Look up the token in the database
        token_record = auth_token_crud.get_token_by_hash(db, token_hash)
        
        if not token_record:
            return None
            
        # Check if the token is expired
        now = datetime.utcnow()
        if token_record.expires_at < now:
            return None
            
        # Check if the token has been used
        if token_record.is_used:
            return None
            
        # Mark the token as used
        auth_token_crud.mark_token_as_used(db, token_record)
        
        return token_record.email
    
    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """
        Creates a short-lived access token with standard claims.
        
        Args:
            data: Dictionary containing claims to include in the token
            expires_delta: Optional custom expiration time
            
        Returns:
            JWT token string
        """
        to_encode = self.encode_data(data, expires_delta, token_type="access")
        
        # Encode the token
        try:
            encoded_jwt = jwt.encode(to_encode, self.jwt_secret_key, algorithm=self.algorithm)
            return encoded_jwt
        except Exception as e:
            logger.error(f"Error creating access token: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Could not create access token"
            )

    def create_refresh_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """
        Creates a long-lived refresh token with standard claims.
        
        Args:
            data: Dictionary containing claims to include in the token
            expires_delta: Optional custom expiration time
            
        Returns:
            JWT token string
        """

        to_encode = self.encode_data(data, expires_delta)
        
        # Encode the token
        try:
            # Use a different key for refresh tokens for better security
            # In production, consider using a completely different key
            encoded_jwt = jwt.encode(to_encode, self.jwt_secret_key, algorithm=self.algorithm)
            return encoded_jwt
        except Exception as e:
            logger.error(f"Error creating refresh token: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Could not create refresh token"
            )
    def encode_data(self, data: dict, expires_delta: Optional[timedelta] = None, token_type: str = "refresh") -> dict:
        to_encode = data.copy()

        # Set expiration time
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(days=self.refresh_token_expire_days)

        # Add standard claims
        jti = str(uuid.uuid4())  # Unique token ID
        iat = datetime.now(timezone.utc)  # Issued at time

        to_encode.update({
            "exp": expire,
            "iat": iat,
            "jti": jti,
            "type": token_type,
            "iss": "nodal-api"  # Issuer
        })

        return to_encode
    
    def verify_token(self, token: str, credentials_exception: HTTPException) -> Dict[str, Any]:
        """
        Verifies a token and returns its payload.
        Performs comprehensive validation of token claims.
        
        Args:
            token: JWT token string to verify
            credentials_exception: Exception to raise if validation fails
            
        Returns:
            Dictionary containing the token claims
            
        Raises:
            HTTPException: If token validation fails
        """
        try:
            # Decode the token
            payload = jwt.decode(
                token, 
                self.jwt_secret_key, 
                algorithms=[self.algorithm],
                options={"verify_signature": True, "verify_exp": True, "verify_aud": False}
            )
            
            # Validate required claims
            if payload.get("sub") is None:
                logger.warning("Token missing 'sub' claim")
                raise credentials_exception
                
            if payload.get("type") is None:
                logger.warning("Token missing 'type' claim")
                raise credentials_exception
                
            if payload.get("jti") is None:
                logger.warning("Token missing 'jti' claim")
                raise credentials_exception
            
            # Validate issuer if present
            if payload.get("iss") and payload.get("iss") != "nodal-api":
                logger.warning(f"Invalid token issuer: {payload.get('iss')}")
                raise credentials_exception
            
            # Check token age (optional additional security)
            if payload.get("iat"):
                issued_at = datetime.fromtimestamp(payload["iat"], tz=timezone.utc)
                now = datetime.now(timezone.utc)
                max_age = timedelta(days=30)  # Maximum token age regardless of exp
                
                if now - issued_at > max_age:
                    logger.warning(f"Token too old: {now - issued_at}")
                    raise credentials_exception
            
            # In a real production system, you might check a token blacklist here
            # to see if the token has been revoked
            
            return payload
            
        except JWTError as e:
            logger.warning(f"JWT validation error: {e}")
            raise credentials_exception
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Error processing authentication token"
            )

# Create a singleton instance
token_service = TokenService()