import logging
import uuid
import hashlib
import secrets
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, Any, Tuple, Union

from jose import JWTError, jwt
from fastapi import HTTPException, status, Depends
from sqlmodel import Session

from app.core.config import settings
from app.db.session import session
from app.crud.auth_tokens import auth_token_crud
from app.services.auth.email_service import email_service
from app.utils.datetime_utils import ensure_timezone_aware
from app.models.auth_token import AuthToken

# Configure logging
logger = logging.getLogger(__name__)

class TokenService:
    """
    Service for handling JWT token operations including creation, validation, and verification.
    This service encapsulates all token-related logic to improve separation of concerns.
    """
    
    def __init__(self):
        self.algorithm = settings.JWT_ALGORITHM
        self.access_token_expire_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
        self.refresh_token_expire_days = settings.REFRESH_TOKEN_EXPIRE_DAYS
        self.auth_token_expire_days = settings.AUTH_TOKEN_EXPIRE_DAYS
        self.jwt_secret_key = settings.JWT_SECRET_KEY
        
    async def generate_email_token(self, email: str, db: Session, is_admin_generated: bool = False) -> Tuple[bool, str]:
        """
        Generate a token and send it to the specified email.
        
        Args:
            email: The email address to send the token to
            db: Database session
            is_admin_generated: Whether the token is being generated by an admin
            
        Returns:
            Tuple of (success, message)
        """
        # Check if the email domain is allowed
        if not email_service.is_domain_allowed(email, db):
            return False, "Email domain not allowed"
        
        # Always check if a token exists for this email
        existing_token = auth_token_crud.get_token_by_email(db, email)
        
        # If a token exists and it's not admin-generated, return an error message
        if existing_token and not is_admin_generated and not auth_token_crud.can_generate_token(db, email):
            # Format the expiration time
            expiration_time = existing_token.expires_at.strftime("%Y-%m-%d %H:%M:%S UTC")
            return False, f"Ya existe un token válido para este correo electrónico. El token expira el {expiration_time}. Por favor, revise su bandeja de entrada o espere a que el token actual expire."
        
        # If a token exists, delete it in the following cases:
        # 1. It's admin-generated
        # 2. It's expired
        # We no longer check if the token is used since tokens can be used multiple times
        if existing_token:
            now = datetime.now(timezone.utc)
            # Ensure expires_at is timezone-aware before comparison
            if is_admin_generated or ensure_timezone_aware(existing_token.expires_at) < now:
                logger.info(f"Deleting existing token for {email} before creating a new one.")
                auth_token_crud.delete_token_by_email(db, email)
            
        # Generate a secure random token
        token = secrets.token_urlsafe(32)
        
        # Hash the token for storage
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        try:
            # Store the token in the database
            auth_token_crud.create_token(
                db=db,
                email=email,
                token_hash=token_hash,
                expires_in_days=self.auth_token_expire_days,
                is_admin_generated=is_admin_generated
            )
        except Exception as e:
            logger.error(f"Error creating token for {email}: {str(e)}")
            return False, "Error creating token. Please try again later."
        
        # Send the token via email
        email_sent = await email_service.send_token_email(email, token, db)
        
        if not email_sent:
            return False, "Failed to send email"
            
        return True, "Token generated and sent successfully"
        
    def verify_email_token(self, token: str, db: Session, return_record: bool = False) -> Union[Optional[str], Tuple[Optional[str], Optional[AuthToken]]]:
        """
        Verify an email token and return the associated email if valid.
        
        Args:
            token: The token to verify
            db: Database session
            return_record: Whether to return the token record along with the email
            
        Returns:
            If return_record is False: The email associated with the token if valid, None otherwise
            If return_record is True: A tuple of (email, token_record) if valid, (None, None) otherwise
        """
        # Hash the token for lookup
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # Look up the token in the database
        token_record = auth_token_crud.get_token_by_hash(db, token_hash)
        
        if not token_record:
            return (None, None) if return_record else None
            
        # Check if the token is expired
        now = datetime.now(timezone.utc)
        # Ensure expires_at is timezone-aware before comparison
        if ensure_timezone_aware(token_record.expires_at) < now:
            return (None, None) if return_record else None
            
        # Removed check for token.is_used and no longer marking token as used
        # This allows tokens to be used multiple times until they expire
        
        return (token_record.email, token_record) if return_record else token_record.email
    
    def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """
        Creates a short-lived access token with standard claims.
        
        Args:
            data: Dictionary containing claims to include in the token
            expires_delta: Optional custom expiration time
            
        Returns:
            JWT token string
        """
        to_encode = self.encode_data(data, expires_delta, token_type="access")
        
        # Encode the token
        try:
            encoded_jwt = jwt.encode(to_encode, self.jwt_secret_key, algorithm=self.algorithm)
            return encoded_jwt
        except Exception as e:
            logger.error(f"Error creating access token: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Could not create access token"
            )

    def create_refresh_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """
        Creates a long-lived refresh token with standard claims.
        
        Args:
            data: Dictionary containing claims to include in the token
            expires_delta: Optional custom expiration time
            
        Returns:
            JWT token string
        """

        to_encode = self.encode_data(data, expires_delta)
        
        # Encode the token
        try:
            # Use a different key for refresh tokens for better security
            # In production, consider using a completely different key
            encoded_jwt = jwt.encode(to_encode, self.jwt_secret_key, algorithm=self.algorithm)
            return encoded_jwt
        except Exception as e:
            logger.error(f"Error creating refresh token: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Could not create refresh token"
            )
    def encode_data(self, data: dict, expires_delta: Optional[timedelta] = None, token_type: str = "refresh") -> dict:
        to_encode = data.copy()

        # Set expiration time
        if expires_delta:
            expire = datetime.now(timezone.utc) + expires_delta
        else:
            expire = datetime.now(timezone.utc) + timedelta(days=self.refresh_token_expire_days)

        # Add standard claims
        jti = str(uuid.uuid4())  # Unique token ID
        iat = datetime.now(timezone.utc)  # Issued at time

        to_encode.update({
            "exp": expire,
            "iat": iat,
            "jti": jti,
            "type": token_type,
            "iss": "nodal-api"  # Issuer
        })

        return to_encode
    
    def verify_token(self, token: str, credentials_exception: HTTPException) -> Dict[str, Any]:
        """
        Verifies a token and returns its payload.
        Performs comprehensive validation of token claims.
        
        Args:
            token: JWT token string to verify
            credentials_exception: Exception to raise if validation fails
            
        Returns:
            Dictionary containing the token claims
            
        Raises:
            HTTPException: If token validation fails
        """
        try:
            # Decode the token
            payload = jwt.decode(
                token, 
                self.jwt_secret_key, 
                algorithms=[self.algorithm],
                options={"verify_signature": True, "verify_exp": True, "verify_aud": False}
            )
            
            # Validate required claims
            if payload.get("sub") is None:
                logger.warning("Token missing 'sub' claim")
                raise credentials_exception
                
            if payload.get("type") is None:
                logger.warning("Token missing 'type' claim")
                raise credentials_exception
                
            if payload.get("jti") is None:
                logger.warning("Token missing 'jti' claim")
                raise credentials_exception
            
            # Validate issuer if present
            if payload.get("iss") and payload.get("iss") != "nodal-api":
                logger.warning(f"Invalid token issuer: {payload.get('iss')}")
                raise credentials_exception
            
            # Check token age (optional additional security)
            if payload.get("iat"):
                issued_at = datetime.fromtimestamp(payload["iat"], tz=timezone.utc)
                now = datetime.now(timezone.utc)
                max_age = timedelta(days=30)  # Maximum token age regardless of exp
                
                if now - issued_at > max_age:
                    logger.warning(f"Token too old: {now - issued_at}")
                    raise credentials_exception
            
            # In a real production system, you might check a token blacklist here
            # to see if the token has been revoked
            
            return payload
            
        except JWTError as e:
            logger.warning(f"JWT validation error: {e}")
            raise credentials_exception
        except Exception as e:
            logger.error(f"Unexpected error verifying token: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Error processing authentication token"
            )

# Create a singleton instance
token_service = TokenService()